{
  "id": "snapshot_1759392070353_vau39awev",
  "approvalId": "approval_1759392070339_u5i1zgc1q",
  "approvalTitle": "heartbeat-counter design",
  "version": 1,
  "timestamp": "2025-10-02T08:01:10.353Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n1 秒ごとに循環カウンターと現在時刻を出力する CLI ユーティリティを `src/main.py` の単一モジュールとして実装する。`time.sleep` を用いたループ制御と `datetime.datetime.now` による時刻取得を組み合わせ、標準出力へ整形済みテキストを流す。SIGINT を捕捉して優雅に終了できるようにする。\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Python 3.11 以上、標準ライブラリのみを利用する方針に従う。\n- 循環カウンター方式と単一ファイル構成を採用し、CPU 負荷を抑えたシーケンシャルループを実装する。\n- 例外処理とフラッシュ制御でリアルタイム性を担保し、tech.md で定義した運用要件を満たす。\n\n### Project Structure (structure.md)\n- 実装は `src/main.py` に配置し、モジュール構成・命名規則 (snake_case) を遵守する。\n- `MAX_COUNT` 定数やフォーマット関数を切り出し、構造ガイドラインのインポート順序・関数構成に合わせる。\n- 将来の拡張を見据え、ユーティリティ分割が容易な形で関数を配置する。\n\n## Code Reuse Analysis\n既存コードはまだ存在しないため新規実装となる。ただし Python 標準ライブラリの `time`, `datetime`, `sys` を活用して要件を満たす。\n\n### Existing Components to Leverage\n- **datetime モジュール**: 現在時刻取得と ISO 8601 形式への整形。\n- **time モジュール**: 1 秒間隔の待機 (`time.sleep`).\n- **sys.stdout/sys.stderr**: 出力フラッシュおよびエラーメッセージ表示。\n\n### Integration Points\n- 外部システムやデータストアとの連携はない。\n\n## Architecture\n\n- 単一モジュールで完結するシーケンシャルなループ構造。\n- 関数分割: 初期化 (`run()`)、次のカウント値計算 (`next_count`)、出力フォーマット (`format_line`)、メインループ (`heartbeat_loop`)。\n- SIGINT をハンドリングするため `KeyboardInterrupt` を捕捉する try/except ブロックを用いる。\n\n### Modular Design Principles\n- **Single File Responsibility**: `main.py` はカウンター制御と表示に限定。\n- **Component Isolation**: カウンター更新ロジックと出力フォーマットを関数化しテストしやすくする。\n- **Service Layer Separation**: 規模が小さいため層分けは最小限だが、将来 `timer.py` 等へスケールできるよう関数 API を明確にする。\n- **Utility Modularity**: 補助関数をトップレベルに定義し、他ファイルから再利用可能な形にする。\n\n```mermaid\ngraph TD\n    A[run()] --> B[heartbeat_loop()]\n    B --> C[next_count()]\n    B --> D[format_line()]\n    B -->|uses| E[time.sleep]\n    D --> F[datetime.now]\n```\n\n## Components and Interfaces\n\n### Component 1: `run()` エントリポイント\n- **Purpose:** 初期状態を設定し、ハートビートループを開始する。\n- **Interfaces:** `run(max_count: int = 100) -> None`\n- **Dependencies:** `heartbeat_loop`\n- **Reuses:** `MAX_COUNT` 定数。\n\n### Component 2: `heartbeat_loop()`\n- **Purpose:** 無限ループでカウンターと時刻を取得し出力する。\n- **Interfaces:** `heartbeat_loop(max_count: int) -> None`\n- **Dependencies:** `next_count`, `format_line`, `time.sleep`, `sys.stdout.flush`\n- **Reuses:** `KeyboardInterrupt` ハンドリングロジック。\n\n### Component 3: `next_count()`\n- **Purpose:** 現在値と上限値から次のカウントを算出する。\n- **Interfaces:** `next_count(current: int, max_count: int) -> int`\n- **Dependencies:** なし\n- **Reuses:** 後続でテスト可能な純粋関数として利用。\n\n### Component 4: `format_line()`\n- **Purpose:** 時刻とカウンターを表示用文字列に変換する。\n- **Interfaces:** `format_line(timestamp: datetime, count: int) -> str`\n- **Dependencies:** `datetime`\n- **Reuses:** フォーマットロジックを一箇所に集約し、将来の出力変更に備える。\n\n## Data Models\nデータベースや複雑なモデルは不要。以下の単純な構造のみ扱う。\n\n### カウンター状態\n```\nCounterState:\n- count: int   # 現在のカウンター値 (0〜100)\n```\n\n### 出力レコード（概念モデル）\n```\nOutputLine:\n- timestamp: datetime\n- count: int\n- text: str  # format_line で生成される出力\n```\n\n## Error Handling\n\n### Error Scenario 1: SIGINT による中断\n- **Handling:** `KeyboardInterrupt` を捕捉し、終了メッセージを `print(\"Interrupted\")` 等で出力後、`return`。\n- **User Impact:** ユーザーは Ctrl+C 後に「Interrupted」メッセージを確認し、安全に終了できる。\n\n### Error Scenario 2: 出力時の例外 (I/O エラー)\n- **Handling:** `IOError` や `OSError` を捕捉し、内容を標準エラーへ書き出した上で非ゼロ終了コードで終了。\n- **User Impact:** ユーザーはエラー内容を把握し、リダイレクト先の問題などを調査できる。\n\n### Error Scenario 3: 時刻取得の例外\n- **Handling:** `datetime.now()` は通常例外を投げないが、念のため予期せぬ例外を最上位で捕捉しログを出力して終了。\n- **User Impact:** 想定外の障害が発生した際も原因を把握しやすい。\n\n## Testing Strategy\n\n### Unit Testing\n- `next_count` の挙動をテストし、0→1、99→100、100→0 などのケースを検証する。\n- `format_line` のフォーマットが ISO 8601 形式であることを確認するスモールテストを用意できる。\n\n### Integration Testing\n- `pytest` から `capsys` を用いて `heartbeat_loop` を短時間実行し、出力のタイミングとフラッシュが行われるかを確認する。\n- SIGINT を疑似的に発生させ、終了メッセージが表示されるかを検証する。\n\n### End-to-End Testing\n- 手動テスト: ターミナルで `python src/main.py` を 5〜10 秒実行し、秒間出力と 100 でのリセット動作を確認。\n- ログへのリダイレクト (`python src/main.py > output.log`) を試み、フラッシュの効果でリアルタイムに追記されることを確認。\n",
  "fileStats": {
    "size": 6314,
    "lines": 120,
    "lastModified": "2025-10-02T08:01:06.697Z"
  },
  "comments": []
}